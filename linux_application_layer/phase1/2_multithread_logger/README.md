# 高并发日志系统

本项目实现了一个高并发日志系统，采用以下技术：
- **无锁环形缓冲区**：多线程日志写入使用固定大小的缓冲区，每条日志固定长度（ LOG_MESSAGE_MAX_LEN 字节）。
- **mmap 崩溃恢复**：使用 `mmap` 将日志缓冲区映射到磁盘文件，支持程序异常退出后的数据恢复。
- **批量写入线程**：后台线程定时从缓冲区取出日志批量写入磁盘文件，降低磁盘 I/O 压力。
- **logger 接口**：简洁的 logger 接口，适用于并发日志场景

## 编译
```bash
make
```

## 运行测试程序
```bash
./test/main
```
日志会写入 `persisted_log.txt` 文件，同时缓冲区数据持久映射到 `log_buffer.mmap` 文件

|**文件名**| **作用** |	**正常内容示例** |
|---------|----------|----------|
| `log_buffer.mmap`	| 临时缓冲（mmap 文件/崩溃恢复）|	最近写入但未持久化的日志 |
| `persisted_log.txt` | 落盘文件，由 disk_writer 写入 |	所有持久化后的日志消息 |

## 文件结构
```
├── log_buffer.[c/h]        # 无锁环形缓冲区实现
├── disk_writer.[c/h]       # 日志写入线程模块
├── crash_recovery.[c/h]    # mmap 崩溃恢复模块
├── logger.[c/h]            # 对外暴露的高级接口
├── main.c                  # 模拟多线程写入日志
├── Makefile
└── README.md
```

## TODO
- 增加日志级别（INFO/WARN/ERROR）
- 支持日志格式化与时间戳
- 日志文件滚动/压缩

## 总结

以上就是一个高并发日志系统的完整实现。整个项目设计了四个主要模块，各自承担不同职责，同时保证在高并发写入时还能实现崩溃恢复。你可以根据需要修改 BUFFER_SIZE、LOG_MESSAGE_MAX_LEN 等参数以适应实际场景。

如果还有问题或需要改进的地方，请告诉我！